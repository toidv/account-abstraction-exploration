"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountSigner = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const bytes_1 = require("@ethersproject/bytes");
const hexlifyOptional = (value) => {
    if (value == null) {
        return undefined;
    }
    return (0, bytes_1.hexlify)(value);
};
class AccountSigner extends abstract_signer_1.Signer {
    constructor(provider) {
        super();
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: provider
        });
        Object.defineProperty(this, "account", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sendUserOperation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "waitForUserOperationTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "withPaymasterMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (overrides) => {
                this.provider.withPaymasterMiddleware(overrides);
                return this;
            }
        });
        Object.defineProperty(this, "withGasEstimator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.provider.withGasEstimator(override);
                return this;
            }
        });
        Object.defineProperty(this, "withFeeDataGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.provider.withFeeDataGetter(override);
                return this;
            }
        });
        Object.defineProperty(this, "withCustomMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.provider.withCustomMiddleware(override);
                return this;
            }
        });
        this.account = this.provider.accountProvider.account;
        this.sendUserOperation =
            this.provider.accountProvider.sendUserOperation.bind(this.provider.accountProvider);
        this.waitForUserOperationTransaction =
            this.provider.accountProvider.waitForUserOperationTransaction.bind(this.provider.accountProvider);
    }
    getAddress() {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        return this.account.getAddress();
    }
    signMessage(message) {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        return this.account.signMessage(message);
    }
    async sendTransaction(transaction) {
        const resolved = await (0, aa_core_1.resolveProperties)(transaction);
        const txHash = await this.provider.accountProvider.sendTransaction({
            from: (await this.getAddress()),
            to: resolved.to,
            data: hexlifyOptional(resolved.data),
        });
        return this.provider.getTransaction(txHash);
    }
    signTransaction(_transaction) {
        throw new Error("Transaction signing is not supported, use sendUserOperation instead");
    }
    getPublicErc4337Client() {
        return this.provider.getPublicErc4337Client();
    }
    connect(provider) {
        return new AccountSigner(provider);
    }
}
exports.AccountSigner = AccountSigner;
//# sourceMappingURL=account-signer.js.map