(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = exports.LogLevel = exports.LogFormat = void 0;
    var LogFormat;
    (function (LogFormat) {
        LogFormat["JSON"] = "{ \"timestamp\": \"${TIMESTAMP}\", \"level\": \"${LEVEL}\", \"name\": \"${NAME}\", \"message\": \"${MESSAGE}\" }";
        LogFormat["JSON_NO_TIME"] = "{ \"level\": \"${LEVEL}\", \"name\": \"${NAME}\", \"message\": \"${MESSAGE}\" }";
        LogFormat["TEXT"] = "[${TIMESTAMP}] [${LEVEL}] [${NAME}] ${MESSAGE}";
        LogFormat["TEXT_NO_TIME"] = "[${LEVEL}] [${NAME}] ${MESSAGE}";
    })(LogFormat || (exports.LogFormat = LogFormat = {}));
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["OFF"] = 1] = "OFF";
        LogLevel[LogLevel["FATAL"] = 2] = "FATAL";
        LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
        LogLevel[LogLevel["WARN"] = 4] = "WARN";
        LogLevel[LogLevel["INFO"] = 5] = "INFO";
        LogLevel[LogLevel["LOG"] = 5] = "LOG";
        LogLevel[LogLevel["DEBUG"] = 6] = "DEBUG";
        LogLevel[LogLevel["TRACE"] = 7] = "TRACE";
        LogLevel[LogLevel["VERBOSE"] = 7] = "VERBOSE";
        LogLevel[LogLevel["ALL"] = 8] = "ALL";
    })(LogLevel || (exports.LogLevel = LogLevel = {}));
    class Logger {
        /* Public Static Fields */
        static Format = LogFormat;
        static Level = LogLevel;
        /* Public Static Methods */
        static getLogger(config = 'Sitka') {
            if (typeof config === 'string') {
                config = { name: config };
            }
            config.name = config.name || 'Sitka';
            if (!Object.prototype.hasOwnProperty.call(this._loggers, config.name)) {
                this._loggers[config.name] = new Logger(config);
            }
            return this._loggers[config.name];
        }
        static setErrorWriter(errorWriter) {
            this._errorWriter = errorWriter;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        static setGlobalContext(context, value) {
            if (typeof context === 'string') {
                this._globalContext[context] = value;
            }
            else {
                this._globalContext = context;
            }
        }
        static setLogWriter(logWriter) {
            this._logWriter = logWriter;
        }
        /* Private Static Fields */
        static _globalContext = {};
        static _loggers = {};
        static _logWriter = console.log; // eslint-disable-line no-console
        static _errorWriter = console.error; // eslint-disable-line no-console
        /* Private Instance Fields */
        _regexDoubleQuote = /"/g;
        _regexNewLine = /\n/g;
        _regexReturn = /\r/g;
        _regexCtx = /[$%]{CTX:([^}]+)}/;
        _regexEnv = /[$%]{ENV:([^}]+)}/;
        _regexEscapedVar = /\\([$%]){/g;
        _regexEscapedSitkaVar = /([$%])_SITKA_ESCAPED_VAR_{/g;
        _regexLevel = /[$%]\{LEVEL\}/g;
        _regexMessage = /[$%]\{MESSAGE\}/g;
        _regexMessageQuoted = /"[$%]\{MESSAGE\}"/;
        _regexTimestamp = /[$%]\{TIMESTAMP\}/g;
        _context;
        _format;
        _level;
        _name;
        _logWriter;
        _errorWriter;
        _useISO8601;
        /* Constructor */
        constructor(config) {
            this._name = config.name;
            this._context = config.context || {};
            const envLogLevel = (this.getEnvVariable('SITKA_LEVEL', true)
                || this.getEnvVariable('LOG_LEVEL', true)).replace(/Log(ger\.)?Level\./, '');
            this._level = config.level
                || (Object.prototype.hasOwnProperty.call(LogLevel, envLogLevel) && LogLevel[envLogLevel])
                || LogLevel.ALL;
            this._logWriter = config.logWriter || undefined;
            this._errorWriter = config.errorWriter || undefined;
            this._format = config.format
                || this.getEnvVariable('SITKA_FORMAT', true)
                || this.getEnvVariable('LOG_FORMAT', true)
                || (this.getEnvVariable('LAMBDA_TASK_ROOT') || this.getEnvVariable('GCP_PROJECT')
                    ? LogFormat.TEXT_NO_TIME : LogFormat.TEXT);
            // Perform static replacements now so fewer are needed for each log entry. -- cwells
            this._format = this._format.replace(this._regexEscapedVar, '$1_SITKA_ESCAPED_VAR_{')
                .replace(/[$%]\{NAME\}/g, this._name);
            const envUseISO8601 = this.getEnvVariable('SITKA_ISO8601', true)
                || this.getEnvVariable('USE_ISO8601', true);
            this._useISO8601 = envUseISO8601 !== 'false';
        }
        /* Public Instance Methods */
        debug(message, ...args) {
            return (this._level >= LogLevel.DEBUG ? this.write('DEBUG', message, ...args) : false);
        }
        error(message, ...args) {
            return (this._level >= LogLevel.ERROR ? this.write('ERROR', message, ...args) : false);
        }
        fatal(message, ...args) {
            return (this._level >= LogLevel.FATAL ? this.write('FATAL', message, ...args) : false);
        }
        info(message, ...args) {
            return (this._level >= LogLevel.INFO ? this.write('INFO', message, ...args) : false);
        }
        // Essentially the same as info(). -- cwells
        log(message, ...args) {
            return (this._level >= LogLevel.LOG ? this.write('LOG', message, ...args) : false);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        setContext(context, value) {
            if (typeof context === 'string') {
                this._context[context] = value;
            }
            else {
                this._context = context;
            }
        }
        trace(message, ...args) {
            return (this._level >= LogLevel.TRACE ? this.write('TRACE', message, ...args) : false);
        }
        // Essentially the same as trace(). -- cwells
        verbose(message, ...args) {
            return (this._level >= LogLevel.VERBOSE ? this.write('VERBOSE', message, ...args) : false);
        }
        warn(message, ...args) {
            return (this._level >= LogLevel.WARN ? this.write('WARN', message, ...args) : false);
        }
        /* Private Instance Methods */
        convertToString(item) {
            if (typeof item === 'undefined') {
                return 'undefined';
            }
            else if (item === null) {
                return 'null';
            }
            else if (typeof item === 'string') {
                return item;
            }
            else if (Array.isArray(item)) {
                const elements = [];
                for (const element of item) {
                    elements.push(this.convertToString(element));
                }
                return '[ ' + elements.join(', ') + ' ]';
            }
            else if (typeof item === 'object') {
                const properties = [];
                for (const property in item) {
                    if (typeof item[property] === 'undefined') {
                        properties.push(property + ': undefined');
                    }
                    else if (item[property] === null) {
                        properties.push(property + ': null');
                    }
                    else if (typeof item[property] === 'string') {
                        properties.push(property + ': "' + item[property] + '"');
                    }
                    else {
                        properties.push(property + ': ' + this.convertToString(item[property]));
                    }
                }
                return '{ ' + properties.join(', ') + ' }';
            }
            else if (typeof item === 'function') {
                return item.toString();
            }
            else {
                return JSON.stringify(item);
            }
        }
        getEnvVariable(property, checkCustom = false) {
            // The keys check allows unit tests to succeed with env overwritten. -- cwells
            if (process && process.env && Object.keys(process.env).length !== 0) {
                if (checkCustom && Object.prototype.hasOwnProperty.call(process.env, property + '_' + this._name)) {
                    return process.env[property + '_' + this._name];
                }
                else if (Object.prototype.hasOwnProperty.call(process.env, property)) {
                    return process.env[property];
                }
            }
            return '';
        }
        write(level, message, ...args) {
            message = this.convertToString(message);
            if (this._regexMessageQuoted.test(this._format)) { // Message is inside quotes, so escape it. -- cwells
                message = message.replace(this._regexDoubleQuote, '\\"')
                    .replace(this._regexNewLine, '\\n')
                    .replace(this._regexReturn, '\\r');
            }
            const timestamp = this._useISO8601 ? new Date().toISOString() : Date();
            message = this._format.replace(this._regexLevel, level)
                .replace(this._regexTimestamp, timestamp)
                .replace(this._regexMessage, message.replace(this._regexEscapedVar, '$1_SITKA_ESCAPED_VAR_{'));
            // Replace ${ENV:VAR} and %{ENV:VAR} with the value of the VAR environment variable. -- cwells
            let matches = message.match(this._regexEnv);
            while (matches && matches.length === 2) {
                message = message.replace(matches[0], this.getEnvVariable(matches[1]));
                matches = message.match(this._regexEnv);
            }
            // Replace ${CTX:VAR} and %{CTX:VAR} with the value of the VAR context variable. -- cwells
            const context = { ...Logger._globalContext, ...this._context };
            matches = message.match(this._regexCtx);
            while (matches && matches.length === 2) {
                let replacement = '';
                if (Object.prototype.hasOwnProperty.call(context, matches[1])) {
                    replacement = this.convertToString(context[matches[1]]);
                }
                else { // Attempt to convert dotted vars into object property references. -- cwells
                    const propNames = matches[1].split('.');
                    if (propNames.length !== 1) {
                        let ctxVar = context;
                        let i;
                        for (i = 0; i < propNames.length; i++) {
                            if (!Object.prototype.hasOwnProperty.call(ctxVar, propNames[i])) {
                                i--; // Decrement i to the last successful match. -- cwells
                                break;
                            }
                            ctxVar = ctxVar[propNames[i]];
                        }
                        if (i === propNames.length) { // Reached end of split, so use the value. -- cwells
                            replacement = this.convertToString(ctxVar);
                        }
                    }
                }
                message = message.replace(matches[0], replacement);
                matches = message.match(this._regexCtx); // Repeat until no matches found. -- cwells
            }
            message = message.replace(this._regexEscapedSitkaVar, '$1{');
            if (level === 'FATAL' || level === 'ERROR') {
                return (this._errorWriter || Logger._errorWriter)(message, ...args);
            }
            else {
                return (this._logWriter || Logger._logWriter)(message, ...args);
            }
        }
    }
    exports.Logger = Logger;
});
//# sourceMappingURL=index.js.map